(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerpolicy&&(i.referrerPolicy=a.referrerpolicy),a.crossorigin==="use-credentials"?i.credentials="include":a.crossorigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(a){if(a.ep)return;a.ep=!0;const i=n(a);fetch(a.href,i)}})();function k(){}function Pe(t){return t()}function me(){return Object.create(null)}function z(t){t.forEach(Pe)}function Be(t){return typeof t=="function"}function R(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function Oe(t){return Object.keys(t).length===0}function Fe(t,...e){if(t==null)return k;const n=t.subscribe(...e);return n.unsubscribe?()=>n.unsubscribe():n}function je(t,e,n){t.$$.on_destroy.push(Fe(e,n))}function h(t,e){t.appendChild(e)}function g(t,e,n){t.insertBefore(e,n||null)}function b(t){t.parentNode&&t.parentNode.removeChild(t)}function ae(t,e){for(let n=0;n<t.length;n+=1)t[n]&&t[n].d(e)}function p(t){return document.createElement(t)}function I(t){return document.createTextNode(t)}function w(){return I(" ")}function G(){return I("")}function oe(t,e,n,r){return t.addEventListener(e,n,r),()=>t.removeEventListener(e,n,r)}function S(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function He(t){return Array.from(t.childNodes)}function F(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}function de(t,e){t.value=e??""}function $e(t,e,n,r){n===null?t.style.removeProperty(e):t.style.setProperty(e,n,r?"important":"")}let X;function J(t){X=t}function Ce(){if(!X)throw new Error("Function called outside component initialization");return X}function We(t){Ce().$$.on_mount.push(t)}const U=[],he=[],te=[],ue=[],Re=Promise.resolve();let se=!1;function qe(){se||(se=!0,Re.then(Ee))}function ie(t){te.push(t)}const ne=new Set;let D=0;function Ee(){if(D!==0)return;const t=X;do{try{for(;D<U.length;){const e=U[D];D++,J(e),De(e.$$)}}catch(e){throw U.length=0,D=0,e}for(J(null),U.length=0,D=0;he.length;)he.pop()();for(let e=0;e<te.length;e+=1){const n=te[e];ne.has(n)||(ne.add(n),n())}te.length=0}while(U.length);for(;ue.length;)ue.pop()();se=!1,ne.clear(),J(t)}function De(t){if(t.fragment!==null){t.update(),z(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(ie)}}const re=new Set;let $;function Z(){$={r:0,c:[],p:$}}function ee(){$.r||z($.c),$=$.p}function v(t,e){t&&t.i&&(re.delete(t),t.i(e))}function A(t,e,n,r){if(t&&t.o){if(re.has(t))return;re.add(t),$.c.push(()=>{re.delete(t),r&&(n&&t.d(1),r())}),t.o(e)}else r&&r()}function x(t){t&&t.c()}function C(t,e,n,r){const{fragment:a,after_update:i}=t.$$;a&&a.m(e,n),r||ie(()=>{const o=t.$$.on_mount.map(Pe).filter(Be);t.$$.on_destroy?t.$$.on_destroy.push(...o):z(o),t.$$.on_mount=[]}),i.forEach(ie)}function W(t,e){const n=t.$$;n.fragment!==null&&(z(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function Le(t,e){t.$$.dirty[0]===-1&&(U.push(t),qe(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function Q(t,e,n,r,a,i,o,l=[-1]){const c=X;J(t);const s=t.$$={fragment:null,ctx:[],props:i,update:k,not_equal:a,bound:me(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(c?c.$$.context:[])),callbacks:me(),dirty:l,skip_bound:!1,root:e.target||c.$$.root};o&&o(s.root);let m=!1;if(s.ctx=n?n(t,e.props||{},(d,u,...f)=>{const _=f.length?f[0]:u;return s.ctx&&a(s.ctx[d],s.ctx[d]=_)&&(!s.skip_bound&&s.bound[d]&&s.bound[d](_),m&&Le(t,d)),u}):[],s.update(),m=!0,z(s.before_update),s.fragment=r?r(s.ctx):!1,e.target){if(e.hydrate){const d=He(e.target);s.fragment&&s.fragment.l(d),d.forEach(b)}else s.fragment&&s.fragment.c();e.intro&&v(t.$$.fragment),C(t,e.target,e.anchor,e.customElement),Ee()}J(c)}class V{$destroy(){W(this,1),this.$destroy=k}$on(e,n){if(!Be(n))return k;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(n),()=>{const a=r.indexOf(n);a!==-1&&r.splice(a,1)}}$set(e){this.$$set&&!Oe(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const Ue=[{0:"initData",1:"String",2:'A string with raw data transferred to the Mini App, convenient for <a href="https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app">validating data</a>.<br><strong>WARNING:</strong> <a href="https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app">Validate data</a> from this field before using it on the bot&#39;s server.'},{0:"initDataUnsafe",1:'<a href="https://core.telegram.org/bots/webapps#webappinitdata">WebAppInitData</a>',2:'An object with input data transferred to the Mini App.<br><strong>WARNING:</strong> Data from this field should not be trusted. You should only use data from <em>initData</em> on the bot&#39;s server and only after it has been <a href="https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app">validated</a>.'},{0:"version",1:"String",2:"The version of the Bot API available in the user&#39;s Telegram app."},{0:"platform",1:"String",2:"The name of the platform of the user&#39;s Telegram app."},{0:"colorScheme",1:"String",2:"The color scheme currently used in the Telegram app. Either “light” or “dark”.<br>Also available as the CSS variable <code>var(--tg-color-scheme)</code>."},{0:"themeParams",1:'<a href="https://core.telegram.org/bots/webapps#themeparams">ThemeParams</a>',2:"An object containing the current theme settings used in the Telegram app."},{0:"isActive <sup><mark>NEW</mark></sup>",1:"Boolean",2:"<mark>Bot API 8.0+</mark> <em>True</em>, if the Mini App is currently active. <em>False</em>, if the Mini App is minimized."},{0:"isExpanded",1:"Boolean",2:"<em>True</em>, if the Mini App is expanded to the maximum available height. False, if the Mini App occupies part of the screen and can be expanded to the full height using the <strong>expand()</strong> method."},{0:"viewportHeight",1:"Float",2:"The current height of the visible area of the Mini App. Also available in CSS as the variable <code>var(--tg-viewport-height)</code>.<br><br>The application can display just the top part of the Mini App, with its lower part remaining outside the screen area. From this position, the user can “pull” the Mini App to its maximum height, while the bot can do the same by calling the <strong>expand()</strong> method. As the position of the Mini App changes, the current height value of the visible area will be updated in real time.<br><br>Please note that the refresh rate of this value is not sufficient to smoothly follow the lower border of the window. It should not be used to pin interface elements to the bottom of the visible area. It&#39;s more appropriate to use the value of the <code>viewportStableHeight</code> field for this purpose."},{0:"viewportStableHeight",1:"Float",2:'The height of the visible area of the Mini App in its last stable state. Also available in CSS as a variable <code>var(--tg-viewport-stable-height)</code>.<br><br>The application can display just the top part of the Mini App, with its lower part remaining outside the screen area. From this position, the user can “pull” the Mini App to its maximum height, while the bot can do the same by calling the <strong>expand()</strong> method. Unlike the value of <code>viewportHeight</code>, the value of <code>viewportStableHeight</code> does not change as the position of the Mini App changes with user gestures or during animations. The value of <code>viewportStableHeight</code> will be updated after all gestures and animations are completed and the Mini App reaches its final size.<br><br><em>Note the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <code>viewportChanged</code> with the passed parameter <code>isStateStable=true</code>, which will allow you to track when the stable state of the height of the visible area changes.</em>'},{0:"headerColor",1:"String",2:"Current header color in the <code>#RRGGBB</code> format."},{0:"backgroundColor",1:"String",2:"Current background color in the <code>#RRGGBB</code> format."},{0:"bottomBarColor",1:"String",2:"Current bottom bar color in the <code>#RRGGBB</code> format."},{0:"isClosingConfirmationEnabled",1:"Boolean",2:"<em>True</em>, if the confirmation dialog is enabled while the user is trying to close the Mini App. <em>False</em>, if the confirmation dialog is disabled."},{0:"isVerticalSwipesEnabled",1:"Boolean",2:"<em>True</em>, if vertical swipes to close or minimize the Mini App are enabled. <em>False</em>, if vertical swipes to close or minimize the Mini App are disabled. In any case, the user will still be able to minimize and close the Mini App by swiping the Mini App&#39;s header."},{0:"isFullscreen <sup><mark>NEW</mark></sup>",1:"Boolean",2:"<em>True</em>, if the Mini App is currently being displayed in fullscreen mode."},{0:"isOrientationLocked <sup><mark>NEW</mark></sup>",1:"Boolean",2:"<em>True</em>, if the Mini App’s orientation is currently locked. <em>False</em>, if orientation changes freely based on the device’s rotation."},{0:"safeAreaInset <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#safeareainset">SafeAreaInset</a>',2:"An object representing the device&#39;s safe area insets, accounting for system UI elements like notches or navigation bars."},{0:"contentSafeAreaInset <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#contentsafeareainset">ContentSafeAreaInset</a>',2:"An object representing the safe area for displaying content within the app, free from overlapping Telegram UI elements."},{0:"BackButton",1:'<a href="https://core.telegram.org/bots/webapps#backbutton">BackButton</a>',2:"An object for controlling the back button which can be displayed in the header of the Mini App in the Telegram interface."},{0:"MainButton",1:'<a href="https://core.telegram.org/bots/webapps#bottombutton">BottomButton</a>',2:"An object for controlling the main button, which is displayed at the bottom of the Mini App in the Telegram interface."},{0:"SecondaryButton",1:'<a href="https://core.telegram.org/bots/webapps#bottombutton">BottomButton</a>',2:"An object for controlling the secondary button, which is displayed at the bottom of the Mini App in the Telegram interface."},{0:"SettingsButton",1:'<a href="https://core.telegram.org/bots/webapps#settingsbutton">SettingsButton</a>',2:"An object for controlling the Settings item in the context menu of the Mini App in the Telegram interface."},{0:"HapticFeedback",1:'<a href="https://core.telegram.org/bots/webapps#hapticfeedback">HapticFeedback</a>',2:"An object for controlling haptic feedback."},{0:"CloudStorage",1:'<a href="https://core.telegram.org/bots/webapps#cloudstorage">CloudStorage</a>',2:"An object for controlling cloud storage."},{0:"BiometricManager",1:'<a href="https://core.telegram.org/bots/webapps#biometricmanager">BiometricManager</a>',2:"An object for controlling biometrics on the device."},{0:"Accelerometer <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#accelerometer">Accelerometer</a>',2:"An object for accessing accelerometer data on the device."},{0:"DeviceOrientation <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#deviceorientation">DeviceOrientation</a>',2:"An object for accessing device orientation data on the device."},{0:"Gyroscope <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#gyroscope">Gyroscope</a>',2:"An object for accessing gyroscope data on the device."},{0:"LocationManager <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#locationmanager">LocationManager</a>',2:"An object for controlling location on the device."},{0:"DeviceStorage <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#devicestorage">DeviceStorage</a>',2:"An object for storing and retrieving data from the device&#39;s local storage."},{0:"SecureStorage <sup><mark>NEW</mark></sup>",1:'<a href="https://core.telegram.org/bots/webapps#securestorage">SecureStorage</a>',2:"An object for storing and retrieving data from the device&#39;s secure storage."},{0:"isVersionAtLeast(version)",1:"Function",2:"Returns true if the user&#39;s app supports a version of the Bot API that is equal to or higher than the version passed as the parameter."},{0:"setHeaderColor(color)",1:"Function",2:"<mark>Bot API 6.1+</mark> A method that sets the app header color in the <code>#RRGGBB</code> format. You can also use keywords <em>bg_color</em> and <em>secondary_bg_color</em>.<br><br>Up to <mark>Bot API 6.9</mark> You can only pass <em>Telegram.WebApp.themeParams.bg_color</em> or <em>Telegram.WebApp.themeParams.secondary_bg_color</em> as a color or <em>bg_color</em>, <em>secondary_bg_color</em> keywords."},{0:"setBackgroundColor(color)",1:"Function",2:"<mark>Bot API 6.1+</mark> A method that sets the app background color in the <code>#RRGGBB</code> format. You can also use keywords <em>bg_color</em> and <em>secondary_bg_color</em>."},{0:"setBottomBarColor(color)",1:"Function",2:"<mark>Bot API 7.10+</mark> A method that sets the app&#39;s bottom bar color in the <code>#RRGGBB</code> format. You can also use the keywords <em>bg_color</em>, <em>secondary_bg_color</em>, and <em>bottom_bar_bg_color</em>. This color is also applied to the navigation bar on Android."},{0:"enableClosingConfirmation()",1:"Function",2:"<mark>Bot API 6.2+</mark> A method that enables a confirmation dialog while the user is trying to close the Mini App."},{0:"disableClosingConfirmation()",1:"Function",2:"<mark>Bot API 6.2+</mark> A method that disables the confirmation dialog while the user is trying to close the Mini App."},{0:"enableVerticalSwipes()",1:"Function",2:"<mark>Bot API 7.7+</mark> A method that enables vertical swipes to close or minimize the Mini App. For user convenience, it is recommended to always enable swipes unless they conflict with the Mini App&#39;s own gestures."},{0:"disableVerticalSwipes()",1:"Function",2:"<mark>Bot API 7.7+</mark> A method that disables vertical swipes to close or minimize the Mini App. This method is useful if your Mini App uses swipe gestures that may conflict with the gestures for minimizing and closing the app."},{0:"requestFullscreen() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that requests opening the Mini App in fullscreen mode. Although the header is transparent in fullscreen mode, it is recommended that the Mini App sets the header color using the <em>setHeaderColor</em> method. This color helps determine a contrasting color for the status bar and other UI controls."},{0:"exitFullscreen() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that requests exiting fullscreen mode."},{0:"lockOrientation() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that locks the Mini App’s orientation to its current mode (either portrait or landscape). Once locked, the orientation remains fixed, regardless of device rotation. This is useful if a stable orientation is needed during specific interactions."},{0:"unlockOrientation() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that unlocks the Mini App’s orientation, allowing it to follow the device&#39;s rotation freely. Use this to restore automatic orientation adjustments based on the device orientation."},{0:"addToHomeScreen() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that prompts the user to add the Mini App to the home screen. After successfully adding the icon, the <code>homeScreenAdded</code> event will be triggered if supported by the device. Note that if the device cannot determine the installation status, the event may not be received even if the icon has been added."},{0:"checkHomeScreenStatus([callback]) <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that checks if adding to the home screen is supported and if the Mini App has already been added. If an optional <em>callback</em> parameter is provided, the <em>callback</em> function will be called with a single argument <em>status</em>, which is a string indicating the home screen status. Possible values for <em>status</em> are:<br>- <strong>unsupported</strong> – the feature is not supported, and it is not possible to add the icon to the home screen,<br>- <strong>unknown</strong> – the feature is supported, and the icon can be added, but it is not possible to determine if the icon has already been added,<br>- <strong>added</strong> – the icon has already been added to the home screen,<br>- <strong>missed</strong> – the icon has not been added to the home screen."},{0:"onEvent(eventType, eventHandler)",1:"Function",2:'A method that sets the app event handler. Check <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">the list of available events</a>.'},{0:"offEvent(eventType, eventHandler)",1:"Function",2:"A method that deletes a previously set event handler."},{0:"sendData(data)",1:"Function",2:'A method used to send data to the bot. When this method is called, a service message is sent to the bot containing the data <em>data</em> of the length up to 4096 bytes, and the Mini App is closed. See the field <em>web_app_data</em> in the class <a href="https://core.telegram.org/bots/api#message">Message</a>.<br><br><em>This method is only available for Mini Apps launched via a <a href="https://core.telegram.org/bots/webapps#keyboard-button-mini-apps">Keyboard button</a>.</em>'},{0:"switchInlineQuery(query[, choose_chat_types])",1:"Function",2:"<mark>Bot API 6.7+</mark> A method that inserts the bot&#39;s username and the specified inline <em>query</em> in the current chat&#39;s input field. Query may be empty, in which case only the bot&#39;s username will be inserted. If an optional <em>choose_chat_types</em> parameter was passed, the client prompts the user to choose a specific chat, then opens that chat and inserts the bot&#39;s username and the specified inline query in the input field. You can specify which types of chats the user will be able to choose from. It can be one or more of the following types: <em>users</em>, <em>bots</em>, <em>groups</em>, <em>channels</em>."},{0:"openLink(url[, options])",1:"Function",2:'A method that opens a link in an external browser. The Mini App will <em>not</em> be closed.<br><mark>Bot API 6.4+</mark> If the optional <em>options</em> parameter is passed with the field <em>try_instant_view=true</em>, the link will be opened in <a href="https://instantview.telegram.org/">Instant View</a> mode if possible.<br><br><em>Note that this method can be called only in response to user interaction with the Mini App interface (e.g. a click inside the Mini App or on the main button)</em>'},{0:"openTelegramLink(url)",1:"Function",2:"A method that opens a telegram link inside the Telegram app. The Mini App will <em>not</em> be closed after this method is called.<br><br>Up to <mark>Bot API 7.0</mark> The Mini App <em>will</em> be closed after this method is called."},{0:"openInvoice(url[, callback])",1:"Function",2:'<mark>Bot API 6.1+</mark> A method that opens an invoice using the link <em>url</em>. The Mini App will receive the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <em>invoiceClosed</em> when the invoice is closed. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called and the invoice status will be passed as the first argument.'},{0:"shareToStory(media_url[, params])",1:"Function",2:'<mark>Bot API 7.8+</mark> A method that opens the native story editor with the media specified in the <em>media_url</em> parameter as an HTTPS URL. An optional <em>params</em> argument of the type <a href="https://core.telegram.org/bots/webapps#storyshareparams">StoryShareParams</a> describes additional sharing settings.'},{0:"shareMessage(msg_id[, callback]) <sup><mark>NEW</mark></sup>",1:"Function",2:'<mark>Bot API 8.0+</mark> A method that opens a dialog allowing the user to share a message provided by the bot. If an optional <em>callback</em> parameter is provided, the <em>callback</em> function will be called with a boolean as the first argument, indicating whether the message was successfully sent. The message id passed to this method must belong to a <a href="https://core.telegram.org/bots/api#preparedinlinemessage">PreparedInlineMessage</a> previously obtained via the Bot API method <a href="https://core.telegram.org/bots/api#savepreparedinlinemessage">savePreparedInlineMessage</a>.'},{0:"setEmojiStatus(custom_emoji_id[, params, callback])",1:"Function",2:'<mark>Bot API 8.0+</mark> A method that opens a dialog allowing the user to set the specified custom emoji as their status. An optional <em>params</em> argument of type <a href="https://core.telegram.org/bots/webapps#emojistatusparams">EmojiStatusParams</a> specifies additional settings, such as duration. If an optional <em>callback</em> parameter is provided, the <em>callback</em> function will be called with a boolean as the first argument, indicating whether the status was set.<br><br><em>Note: this method opens a native dialog and cannot be used to set the emoji status without manual user interaction. For fully programmatic changes, you should instead use the Bot API method <a href="bots/api#setuseremojistatus">setUserEmojiStatus</a> after obtaining authorization to do so via the Mini App method requestEmojiStatusAccess.</em>'},{0:"requestEmojiStatusAccess([callback]) <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 8.0+</mark> A method that shows a native popup requesting permission for the bot to manage user&#39;s emoji status. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called when the popup is closed and the first argument will be a boolean indicating whether the user granted this access."},{0:"downloadFile(params[, callback]) <sup><mark>NEW</mark></sup>",1:"Function",2:'<mark>Bot API 8.0+</mark> A method that displays a native popup prompting the user to download a file specified by the <em>params</em> argument of type <a href="https://core.telegram.org/bots/webapps#downloadfileparams">DownloadFileParams</a>. If an optional <em>callback</em> parameter is provided, the <em>callback</em> function will be called when the popup is closed, with the first argument as a boolean indicating whether the user accepted the download request.'},{0:"hideKeyboard() <sup><mark>NEW</mark></sup>",1:"Function",2:"<mark>Bot API 9.1+</mark> A method that hides the on-screen keyboard, if it is currently visible. Does nothing if the keyboard is not active."},{0:"showPopup(params[, callback])",1:"Function",2:'<mark>Bot API 6.2+</mark> A method that shows a native popup described by the <em>params</em> argument of the type <a href="https://core.telegram.org/bots/webapps#popupparams">PopupParams</a>. The Mini App will receive the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <em>popupClosed</em> when the popup is closed. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called and the field <em>id</em> of the pressed button will be passed as the first argument.'},{0:"showAlert(message[, callback])",1:"Function",2:"<mark>Bot API 6.2+</mark> A method that shows <em>message</em> in a simple alert with a &#39;Close&#39; button. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called when the popup is closed."},{0:"showConfirm(message[, callback])",1:"Function",2:"<mark>Bot API 6.2+</mark> A method that shows <em>message</em> in a simple confirmation window with &#39;OK&#39; and &#39;Cancel&#39; buttons. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called when the popup is closed and the first argument will be a boolean indicating whether the user pressed the &#39;OK&#39; button."},{0:"showScanQrPopup(params[, callback])",1:"Function",2:'<mark>Bot API 6.4+</mark> A method that shows a native popup for scanning a QR code described by the <em>params</em> argument of the type <a href="https://core.telegram.org/bots/webapps#scanqrpopupparams">ScanQrPopupParams</a>. The Mini App will receive the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <em>qrTextReceived</em> every time the scanner catches a code with text data. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called and the text from the QR code will be passed as the first argument. Returning <em>true</em> inside this callback function causes the popup to be closed. Starting from <mark>Bot API 7.7</mark>, the Mini App will receive the <em>scanQrPopupClosed</em> event if the user closes the native popup for scanning a QR code.'},{0:"closeScanQrPopup()",1:"Function",2:'<mark>Bot API 6.4+</mark> A method that closes the native popup for scanning a QR code opened with the <em>showScanQrPopup</em> method. Run it if you received valid data in the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <em>qrTextReceived</em>.'},{0:"readTextFromClipboard([callback])",1:"Function",2:'<mark>Bot API 6.4+</mark> A method that requests text from the clipboard. The Mini App will receive the <a href="https://core.telegram.org/bots/webapps#events-available-for-mini-apps">event</a> <em>clipboardTextReceived</em>. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called and the text from the clipboard will be passed as the first argument.<br><br><em>Note: this method can be called only for Mini Apps launched from the attachment menu and only in response to a user interaction with the Mini App interface (e.g. a click inside the Mini App or on the main button).</em>'},{0:"requestWriteAccess([callback])",1:"Function",2:"<mark>Bot API 6.9+</mark> A method that shows a native popup requesting permission for the bot to send messages to the user. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called when the popup is closed and the first argument will be a boolean indicating whether the user granted this access."},{0:"requestContact([callback])",1:"Function",2:"<mark>Bot API 6.9+</mark> A method that shows a native popup prompting the user for their phone number. If an optional <em>callback</em> parameter was passed, the <em>callback</em> function will be called when the popup is closed and the first argument will be a boolean indicating whether the user shared its phone number."},{0:"ready()",1:"Function",2:"A method that informs the Telegram app that the Mini App is ready to be displayed.<br>It is recommended to call this method as early as possible, as soon as all essential interface elements are loaded. Once this method is called, the loading placeholder is hidden and the Mini App is shown.<br>If the method is not called, the placeholder will be hidden only when the page is fully loaded."},{0:"expand()",1:"Function",2:"A method that expands the Mini App to the maximum available height. To find out if the Mini App is expanded to the maximum height, refer to the value of the <em>Telegram.WebApp.isExpanded</em> parameter"},{0:"close()",1:"Function",2:"A method that closes the Mini App."}],xe=[{0:"<code>activated</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the Mini App becomes active (e.g., opened from minimized state or selected among tabs).<br><em>eventHandler</em> receives no parameters."},{0:"<code>deactivated</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the Mini App becomes inactive (e.g., minimized or moved to an inactive tab).<br><em>eventHandler</em> receives no parameters."},{0:"<code>themeChanged</code>",1:"Occurs whenever theme settings are changed in the user&#39;s Telegram app (including switching to night mode).<br><em>eventHandler</em> receives no parameters, new theme settings and color scheme can be received via <em>this.themeParams</em> and <em>this.colorScheme</em> respectively."},{0:"<code>viewportChanged</code>",1:"Occurs when the visible section of the Mini App is changed.<br><em>eventHandler</em> receives an object with the single field <em>isStateStable</em>. If <em>isStateStable</em> is true, the resizing of the Mini App is finished. If it is false, the resizing is ongoing (the user is expanding or collapsing the Mini App or an animated object is playing). The current value of the visible section’s height is available in <em>this.viewportHeight</em>."},{0:"<code>safeAreaChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the device&#39;s safe area insets change (e.g., due to orientation change or screen adjustments).<br><em>eventHandler</em> receives no parameters. The current inset values can be accessed via <em>this.safeAreaInset</em>."},{0:"<code>contentSafeAreaChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the safe area for content changes (e.g., due to orientation change or screen adjustments).<br><em>eventHandler</em> receives no parameters. The current inset values can be accessed via <em>this.contentSafeAreaInset</em>."},{0:"<code>mainButtonClicked</code>",1:'Occurs when the <a href="https://core.telegram.org/bots/webapps#bottombutton">main button</a> is pressed.<br><em>eventHandler</em> receives no parameters.'},{0:"<code>secondaryButtonClicked</code>",1:'<mark>Bot API 7.10+</mark> Occurs when the <a href="https://core.telegram.org/bots/webapps#bottombutton">secondary button</a> is pressed.<br><em>eventHandler</em> receives no parameters.'},{0:"<code>backButtonClicked</code>",1:'<mark>Bot API 6.1+</mark> Occurrs when the <a href="https://core.telegram.org/bots/webapps#backbutton">back button</a> is pressed.<br><em>eventHandler</em> receives no parameters.'},{0:"<code>settingsButtonClicked</code>",1:"<mark>Bot API 6.1+</mark> Occurrs when the Settings item in context menu is pressed.<br><em>eventHandler</em> receives no parameters."},{0:"<code>invoiceClosed</code>",1:'<mark>Bot API 6.1+</mark> Occurrs when the opened invoice is closed.<br><em>eventHandler</em> receives an object with the two fields: <em>url</em> – invoice link provided and <em>status</em> – one of the invoice statuses:<br>- <strong>paid</strong> – invoice was paid successfully,<br>- <strong>cancelled</strong> – user closed this invoice without paying,<br>- <strong>failed</strong> – user tried to pay, but the payment was failed,<br>- <strong>pending</strong> – the payment is still processing. The bot will receive a service message about a <a href="https://core.telegram.org/bots/api#successfulpayment">successful payment</a> when the payment is successfully paid.'},{0:"<code>popupClosed</code>",1:"<mark>Bot API 6.2+</mark> Occurrs when the opened popup is closed.<br><em>eventHandler</em> receives an object with the single field <em>button_id</em> – the value of the field <em>id</em> of the pressed button. If no buttons were pressed, the field <em>button_id</em> will be <em>null</em>."},{0:"<code>qrTextReceived</code>",1:"<mark>Bot API 6.4+</mark> Occurs when the QR code scanner catches a code with text data.<br><em>eventHandler</em> receives an object with the single field <em>data</em> containing text data from the QR code."},{0:"<code>scanQrPopupClosed</code>",1:"<mark>Bot API 7.7+</mark> Occurs when the QR code scanner popup is closed by the user.<br><em>eventHandler</em> receives no parameters."},{0:"<code>clipboardTextReceived</code>",1:"<mark>Bot API 6.4+</mark> Occurrs when the <code>readTextFromClipboard</code> method is called.<br><em>eventHandler</em> receives an object with the single field <em>data</em> containing text data from the clipboard. If the clipboard contains non-text data, the field <em>data</em> will be an empty string. If the Mini App has no access to the clipboard, the field <em>data</em> will be <em>null</em>."},{0:"<code>writeAccessRequested</code>",1:"<mark>Bot API 6.9+</mark> Occurs when the write permission was requested.<br><em>eventHandler</em> receives an object with the single field <em>status</em> containing one of the statuses:<br>- <strong>allowed</strong> – user granted write permission to the bot,<br>- <strong>cancelled</strong> – user declined this request."},{0:"<code>contactRequested</code>",1:"<mark>Bot API 6.9+</mark> Occurrs when the user&#39;s phone number was requested.<br><em>eventHandler</em> receives an object with the single field <em>status</em> containing one of the statuses:<br>- <strong>sent</strong> – user shared their phone number with the bot,<br>- <strong>cancelled</strong> – user declined this request."},{0:"<code>biometricManagerUpdated</code>",1:"<mark>Bot API 7.2+</mark> Occurs whenever BiometricManager object is changed.<br><em>eventHandler</em> receives no parameters."},{0:"<code>biometricAuthRequested</code>",1:"<mark>Bot API 7.2+</mark> Occurs whenever biometric authentication was requested.<br><em>eventHandler</em> receives an object with the field <em>isAuthenticated</em> containing a boolean indicating whether the user was authenticated successfully. If <em>isAuthenticated</em> is true, the field <em>biometricToken</em> will contain the biometric token stored in secure storage on the device."},{0:"<code>biometricTokenUpdated</code>",1:"<mark>Bot API 7.2+</mark> Occurs whenever the biometric token was updated.<br><em>eventHandler</em> receives an object with the single field <em>isUpdated</em>, containing a boolean indicating whether the token was updated."},{0:"<code>fullscreenChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs whenever the Mini App enters or exits fullscreen mode.<br><em>eventHandler</em> receives no parameters. The current fullscreen state can be checked via <em>this.isFullscreen</em>."},{0:"<code>fullscreenFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if a request to enter fullscreen mode fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – Fullscreen mode is not supported on this device or platform.<br><strong>ALREADY_FULLSCREEN</strong> – The Mini App is already in fullscreen mode."},{0:"<code>homeScreenAdded</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the Mini App is successfully added to the home screen.<br><em>eventHandler</em> receives no parameters."},{0:"<code>homeScreenChecked</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs after checking the home screen status.<br><em>eventHandler</em> receives an object with the field <em>status</em>, which is a string indicating the current home screen status. Possible values for <em>status</em> are:<br>- <strong>unsupported</strong> – the feature is not supported, and it is not possible to add the icon to the home screen,<br>- <strong>unknown</strong> – the feature is supported, and the icon can be added, but it is not possible to determine if the icon has already been added,<br>- <strong>added</strong> – the icon has already been added to the home screen,<br>- <strong>missed</strong> – the icon has not been added to the home screen."},{0:"<code>accelerometerStarted</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when accelerometer tracking has started successfully.<br><em>eventHandler</em> receives no parameters."},{0:"<code>accelerometerStopped</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when accelerometer tracking has stopped.<br><em>eventHandler</em> receives no parameters."},{0:"<code>accelerometerChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs with the specified frequency after calling the <code>start</code> method, sending the current accelerometer data.<br><em>eventHandler</em> receives no parameters, the current acceleration values can be received via <em>this.x</em>, <em>this.y</em> and <em>this.z</em> respectively."},{0:"<code>accelerometerFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if a request to start accelerometer tracking fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – Accelerometer tracking is not supported on this device or platform."},{0:"<code>deviceOrientationStarted</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when device orientation tracking has started successfully.<br><em>eventHandler</em> receives no parameters."},{0:"<code>deviceOrientationStopped</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when device orientation tracking has stopped.<br><em>eventHandler</em> receives no parameters."},{0:"<code>deviceOrientationChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs with the specified frequency after calling the <code>start</code> method, sending the current orientation data.<br><em>eventHandler</em> receives no parameters, the current device orientation values can be received via <em>this.alpha</em>, <em>this.beta</em> and <em>this.gamma</em> respectively."},{0:"<code>deviceOrientationFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if a request to start device orientation tracking fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – Device orientation tracking is not supported on this device or platform."},{0:"<code>gyroscopeStarted</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when gyroscope tracking has started successfully.<br><em>eventHandler</em> receives no parameters."},{0:"<code>gyroscopeStopped</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when gyroscope tracking has stopped.<br><em>eventHandler</em> receives no parameters."},{0:"<code>gyroscopeChanged</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs with the specified frequency after calling the <code>start</code> method, sending the current gyroscope data.<br><em>eventHandler</em> receives no parameters, the current rotation rates can be received via <em>this.x</em>, <em>this.y</em> and <em>this.z</em> respectively."},{0:"<code>gyroscopeFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if a request to start gyroscope tracking fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – Gyroscope tracking is not supported on this device or platform."},{0:"<code>locationManagerUpdated</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs whenever LocationManager object is changed.<br><em>eventHandler</em> receives no parameters."},{0:"<code>locationRequested</code> <sup><mark>NEW</mark></sup>",1:'<mark>Bot API 8.0+</mark> Occurs when location data is requested.<br><em>eventHandler</em> receives an object with the single field <em>locationData</em> of type <a href="https://core.telegram.org/bots/webapps#locationdata">LocationData</a>, containing the current location information.'},{0:"<code>shareMessageSent</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the message is successfully shared by the user.<br><em>eventHandler</em> receives no parameters."},{0:"<code>shareMessageFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if sharing the message fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – The feature is not supported by the client.<br><strong>MESSAGE_EXPIRED</strong> – The message could not be retrieved because it has expired.<br><strong>MESSAGE_SEND_FAILED</strong> – An error occurred while attempting to send the message.<br><strong>USER_DECLINED</strong> – The user closed the dialog without sharing the message.<br><strong>UNKNOWN_ERROR</strong> – An unknown error occurred."},{0:"<code>emojiStatusSet</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the emoji status is successfully set.<br><em>eventHandler</em> receives no parameters."},{0:"<code>emojiStatusFailed</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs if setting the emoji status fails.<br><em>eventHandler</em> receives an object with the single field <em>error</em>, describing the reason for the failure. Possible values for <em>error</em> are:<br><strong>UNSUPPORTED</strong> – The feature is not supported by the client.<br><strong>SUGGESTED_EMOJI_INVALID</strong> – One or more emoji identifiers are invalid.<br><strong>DURATION_INVALID</strong> – The specified duration is invalid.<br><strong>USER_DECLINED</strong> – The user closed the dialog without setting a status.<br><strong>SERVER_ERROR</strong> – A server error occurred when attempting to set the status.<br><strong>UNKNOWN_ERROR</strong> – An unknown error occurred."},{0:"<code>emojiStatusAccessRequested</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the write permission was requested.<br><em>eventHandler</em> receives an object with the single field <em>status</em> containing one of the statuses:<br>- <strong>allowed</strong> – user granted emoji status permission to the bot,<br>- <strong>cancelled</strong> – user declined this request."},{0:"<code>fileDownloadRequested</code> <sup><mark>NEW</mark></sup>",1:"<mark>Bot API 8.0+</mark> Occurs when the user responds to the file download request.<br><em>eventHandler</em> receives an object with the single field <em>status</em> containing one of the statuses:<br>- <strong>downloading</strong> – the file download has started,<br>- <strong>cancelled</strong> – user declined this request."}],pe={fieldsData:Ue,eventsData:xe},L=[];function ze(t,e=k){let n;const r=new Set;function a(l){if(R(t,l)&&(t=l,n)){const c=!L.length;for(const s of r)s[1](),L.push(s,t);if(c){for(let s=0;s<L.length;s+=2)L[s][0](L[s+1]);L.length=0}}}function i(l){a(l(t))}function o(l,c=k){const s=[l,c];return r.add(s),r.size===1&&(n=e(a)||k),l(t),()=>{r.delete(s),r.size===0&&(n(),n=null)}}return{set:a,update:i,subscribe:o}}const Se=ze(window.Telegram.WebApp);function Me(){Se.set(window.Telegram.WebApp)}function Ge(t){let e,n,r;return{c(){e=p("pre"),n=p("code"),r=I(t[0]),S(e,"class","svelte-1yitnnt")},m(a,i){g(a,e,i),h(e,n),h(n,r)},p(a,[i]){i&1&&F(r,a[0])},i:k,o:k,d(a){a&&b(e)}}}function Qe(t,e,n){let{name:r}=e,a=`Events will be displayed here:
`;return We(()=>{const i=window.Telegram.WebApp.onEvent;typeof i=="function"&&i(r,(...o)=>{n(0,a+=`${JSON.stringify(o)}
`),Me()})}),t.$$set=i=>{"name"in i&&n(1,r=i.name)},[a,r]}class Ve extends V{constructor(e){super(),Q(this,e,Qe,Ge,R,{name:1})}}function fe(t,e,n){const r=t.slice();return r[1]=e[n],r}function be(t){let e,n,r,a=t[1][0]+"",i,o,l,c,s,m,d,u,f,_=t[1][1]+"",K,N,j,O,P,Y,E;return P=new Ve({props:{name:ge(t[1][0])}}),{c(){e=p("details"),n=p("summary"),r=p("span"),i=w(),o=p("div"),l=p("table"),c=p("colgroup"),c.innerHTML=`<col width="30%"/> 
                    <col width="70%"/>`,s=w(),m=p("tbody"),d=p("tr"),u=p("th"),u.textContent="Description",f=p("td"),K=w(),N=p("tr"),j=p("th"),j.textContent="Playground",O=p("td"),x(P.$$.fragment),Y=w(),S(l,"class","svelte-1y0rnzj"),S(o,"class","content-wrapper svelte-1y0rnzj")},m(y,M){g(y,e,M),h(e,n),h(n,r),r.innerHTML=a,h(e,i),h(e,o),h(o,l),h(l,c),h(l,s),h(l,m),h(m,d),h(d,u),h(d,f),f.innerHTML=_,h(m,K),h(m,N),h(N,j),h(N,O),C(P,O,null),h(e,Y),E=!0},p(y,M){(!E||M&1)&&a!==(a=y[1][0]+"")&&(r.innerHTML=a),(!E||M&1)&&_!==(_=y[1][1]+"")&&(f.innerHTML=_);const T={};M&1&&(T.name=ge(y[1][0])),P.$set(T)},i(y){E||(v(P.$$.fragment,y),E=!0)},o(y){A(P.$$.fragment,y),E=!1},d(y){y&&b(e),W(P)}}}function Ke(t){let e,n,r=t[0],a=[];for(let o=0;o<r.length;o+=1)a[o]=be(fe(t,r,o));const i=o=>A(a[o],1,1,()=>{a[o]=null});return{c(){for(let o=0;o<a.length;o+=1)a[o].c();e=G()},m(o,l){for(let c=0;c<a.length;c+=1)a[c].m(o,l);g(o,e,l),n=!0},p(o,[l]){if(l&1){r=o[0];let c;for(c=0;c<r.length;c+=1){const s=fe(o,r,c);a[c]?(a[c].p(s,l),v(a[c],1)):(a[c]=be(s),a[c].c(),v(a[c],1),a[c].m(e.parentNode,e))}for(Z(),c=r.length;c<a.length;c+=1)i(c);ee()}},i(o){if(!n){for(let l=0;l<r.length;l+=1)v(a[l]);n=!0}},o(o){a=a.filter(Boolean);for(let l=0;l<a.length;l+=1)A(a[l]);n=!1},d(o){ae(a,o),o&&b(e)}}}function ge(t){return t.match(/<code>(.+)<\/code>/)[1]}function Ye(t,e,n){let{data:r}=e;return t.$$set=a=>{"data"in a&&n(0,r=a.data)},[r]}class Je extends V{constructor(e){super(),Q(this,e,Ye,Ke,R,{data:0})}}function Xe(t){return t!=null}function Ze(t){return(t+"").replace(/[/][/].*$/gm,"").replace(/\s+/g,"").replace(/[/][*][^/*]*[*][/]/g,"").split("){",1)[0].replace(/^[^(]*[(]/,"").replace(/=[^,]+/g,"").split(",").filter(Boolean)}function ke(t,e,n){const r=t.slice();return r[7]=e[n],r[8]=e,r[9]=n,r}function ve(t){let e,n=t[7]+"",r,a,i,o,l,c;function s(){t[6].call(i,t[7])}return{c(){e=p("label"),r=I(n),a=w(),i=p("input"),o=w(),S(i,"type","text"),i.disabled=t[7]===Te,S(e,"class","svelte-b2tya0")},m(m,d){g(m,e,d),h(e,r),h(e,a),h(e,i),de(i,t[1][t[7]]),h(e,o),l||(c=[oe(i,"input",t[3](t[7])),oe(i,"input",s)],l=!0)},p(m,d){t=m,d&6&&i.value!==t[1][t[7]]&&de(i,t[1][t[7]])},d(m){m&&b(e),l=!1,z(c)}}}function et(t){let e,n,r,a,i,o,l,c=t[2],s=[];for(let m=0;m<c.length;m+=1)s[m]=ve(ke(t,c,m));return{c(){e=p("div"),n=p("button"),r=I(t[0]),a=w(),i=p("div");for(let m=0;m<s.length;m+=1)s[m].c();S(i,"class","input-container svelte-b2tya0"),S(e,"class","container svelte-b2tya0")},m(m,d){g(m,e,d),h(e,n),h(n,r),h(e,a),h(e,i);for(let u=0;u<s.length;u+=1)s[u].m(i,null);o||(l=oe(n,"click",t[4]),o=!0)},p(m,[d]){if(d&1&&F(r,m[0]),d&14){c=m[2];let u;for(u=0;u<c.length;u+=1){const f=ke(m,c,u);s[u]?s[u].p(f,d):(s[u]=ve(f),s[u].c(),s[u].m(i,null))}for(;u<s.length;u+=1)s[u].d(1);s.length=c.length}},i:k,o:k,d(m){m&&b(e),ae(s,m),o=!1,l()}}}const Te="callback";function tt(t,e,n){let{name:r}=e,{func:a}=e;const i=Ze(a),o=i.reduce((m,d)=>({...m,[d]:""}),{});function l(m){return d=>{n(1,o[m]=d.target.value,o)}}function c(){const m=Object.keys(o).map(d=>d===Te?(...u)=>{n(1,o[d]=JSON.stringify(u),o)}:o[d]);Me(),a(...m)}function s(m){o[m]=this.value,n(1,o)}return t.$$set=m=>{"name"in m&&n(0,r=m.name),"func"in m&&n(5,a=m.func)},[r,o,i,l,c,a,s]}class Ne extends V{constructor(e){super(),Q(this,e,tt,et,R,{name:0,func:5})}}function we(t,e,n){const r=t.slice();return r[4]=e[n],r}function rt(t){let e,n,r,a;return{c(){e=p("p"),n=I("Value "),r=I(t[0]),a=I(" not found.")},m(i,o){g(i,e,o),h(e,n),h(e,r),h(e,a)},p(i,o){o&1&&F(r,i[0])},i:k,o:k,d(i){i&&b(e)}}}function at(t){let e,n,r,a;const i=[ct,it,st,ot,nt],o=[];function l(c,s){return typeof c[1]=="number"||typeof c[1]=="boolean"?0:typeof c[1]=="string"?1:typeof c[1]=="object"?2:typeof c[1]=="function"?3:4}return e=l(t),n=o[e]=i[e](t),{c(){n.c(),r=G()},m(c,s){o[e].m(c,s),g(c,r,s),a=!0},p(c,s){let m=e;e=l(c),e===m?o[e].p(c,s):(Z(),A(o[m],1,1,()=>{o[m]=null}),ee(),n=o[e],n?n.p(c,s):(n=o[e]=i[e](c),n.c()),v(n,1),n.m(r.parentNode,r))},i(c){a||(v(n),a=!0)},o(c){A(n),a=!1},d(c){o[e].d(c),c&&b(r)}}}function nt(t){let e,n,r=typeof t[1],a,i;return{c(){e=p("p"),n=I("Unsupported type "),a=I(r),i=I(".")},m(o,l){g(o,e,l),h(e,n),h(e,a),h(e,i)},p(o,l){l&2&&r!==(r=typeof o[1])&&F(a,r)},i:k,o:k,d(o){o&&b(e)}}}function ot(t){let e,n;return e=new Ne({props:{name:t[0],func:t[1]}}),{c(){x(e.$$.fragment)},m(r,a){C(e,r,a),n=!0},p(r,a){const i={};a&1&&(i.name=r[0]),a&2&&(i.func=r[1]),e.$set(i)},i(r){n||(v(e.$$.fragment,r),n=!0)},o(r){A(e.$$.fragment,r),n=!1},d(r){W(e,r)}}}function st(t){let e,n,r=JSON.stringify(t[1],null,2)+"",a,i,o,l,c=Object.keys(t[1]).filter(t[3]),s=[];for(let d=0;d<c.length;d+=1)s[d]=Ae(we(t,c,d));const m=d=>A(s[d],1,1,()=>{s[d]=null});return{c(){e=p("pre"),n=p("code"),a=I(r),i=w();for(let d=0;d<s.length;d+=1)s[d].c();o=G()},m(d,u){g(d,e,u),h(e,n),h(n,a),g(d,i,u);for(let f=0;f<s.length;f+=1)s[f].m(d,u);g(d,o,u),l=!0},p(d,u){if((!l||u&2)&&r!==(r=JSON.stringify(d[1],null,2)+"")&&F(a,r),u&2){c=Object.keys(d[1]).filter(d[3]);let f;for(f=0;f<c.length;f+=1){const _=we(d,c,f);s[f]?(s[f].p(_,u),v(s[f],1)):(s[f]=Ae(_),s[f].c(),v(s[f],1),s[f].m(o.parentNode,o))}for(Z(),f=c.length;f<s.length;f+=1)m(f);ee()}},i(d){if(!l){for(let u=0;u<c.length;u+=1)v(s[u]);l=!0}},o(d){s=s.filter(Boolean);for(let u=0;u<s.length;u+=1)A(s[u]);l=!1},d(d){d&&b(e),d&&b(i),ae(s,d),d&&b(o)}}}function it(t){let e;function n(i,o){return i[1].length>20?mt:lt}let r=n(t),a=r(t);return{c(){a.c(),e=G()},m(i,o){a.m(i,o),g(i,e,o)},p(i,o){r===(r=n(i))&&a?a.p(i,o):(a.d(1),a=r(i),a&&(a.c(),a.m(e.parentNode,e)))},i:k,o:k,d(i){a.d(i),i&&b(e)}}}function ct(t){let e,n;return{c(){e=p("code"),n=I(t[1])},m(r,a){g(r,e,a),h(e,n)},p(r,a){a&2&&F(n,r[1])},i:k,o:k,d(r){r&&b(e)}}}function Ae(t){let e,n;return e=new Ne({props:{name:t[4],func:t[1][t[4]]}}),{c(){x(e.$$.fragment)},m(r,a){C(e,r,a),n=!0},p(r,a){const i={};a&2&&(i.name=r[4]),a&2&&(i.func=r[1][r[4]]),e.$set(i)},i(r){n||(v(e.$$.fragment,r),n=!0)},o(r){A(e.$$.fragment,r),n=!1},d(r){W(e,r)}}}function lt(t){let e,n;return{c(){e=p("code"),n=I(t[1])},m(r,a){g(r,e,a),h(e,n)},p(r,a){a&2&&F(n,r[1])},d(r){r&&b(e)}}}function mt(t){let e,n,r;return{c(){e=p("pre"),n=p("code"),r=I(t[1])},m(a,i){g(a,e,i),h(e,n),h(n,r)},p(a,i){i&2&&F(r,a[1])},d(a){a&&b(e)}}}function dt(t){let e,n,r,a,i;const o=[at,rt],l=[];function c(s,m){return m&3&&(e=null),e==null&&(e=!!(s[0]&&Xe(s[1]))),e?0:1}return n=c(t,-1),r=l[n]=o[n](t),{c(){r.c(),a=G()},m(s,m){l[n].m(s,m),g(s,a,m),i=!0},p(s,[m]){let d=n;n=c(s,m),n===d?l[n].p(s,m):(Z(),A(l[d],1,1,()=>{l[d]=null}),ee(),r=l[n],r?r.p(s,m):(r=l[n]=o[n](s),r.c()),v(r,1),r.m(a.parentNode,a))},i(s){i||(v(r),i=!0)},o(s){A(r),i=!1},d(s){l[n].d(s),s&&b(a)}}}function ht(t,e,n){let r,a;je(t,Se,l=>n(2,a=l));let{name:i}=e;const o=l=>typeof r[l]=="function";return t.$$set=l=>{"name"in l&&n(0,i=l.name)},t.$$.update=()=>{t.$$.dirty&5&&n(1,r=a[i])},[i,r,a,o]}class ut extends V{constructor(e){super(),Q(this,e,ht,dt,R,{name:0})}}function _e(t,e,n){const r=t.slice();return r[1]=e[n],r}function ye(t){let e,n,r,a=t[1][0]+"",i,o,l,c,s,m,d,u,f,_=t[1][1]+"",K,N,j,O,P=t[1][2]+"",Y,E,y,M,T,ce,H;return T=new ut({props:{name:Ie(t[1][0])}}),{c(){e=p("details"),n=p("summary"),r=p("span"),i=w(),o=p("div"),l=p("table"),c=p("colgroup"),c.innerHTML=`<col width="30%"/> 
                    <col width="70%"/>`,s=w(),m=p("tbody"),d=p("tr"),u=p("th"),u.textContent="Type",f=p("td"),K=w(),N=p("tr"),j=p("th"),j.textContent="Description",O=p("td"),Y=w(),E=p("tr"),y=p("th"),y.textContent="Playground",M=p("td"),x(T.$$.fragment),ce=w(),$e(M,"width","30%"),S(l,"class","svelte-1y0rnzj"),S(o,"class","content-wrapper svelte-1y0rnzj")},m(B,q){g(B,e,q),h(e,n),h(n,r),r.innerHTML=a,h(e,i),h(e,o),h(o,l),h(l,c),h(l,s),h(l,m),h(m,d),h(d,u),h(d,f),f.innerHTML=_,h(m,K),h(m,N),h(N,j),h(N,O),O.innerHTML=P,h(m,Y),h(m,E),h(E,y),h(E,M),C(T,M,null),h(e,ce),H=!0},p(B,q){(!H||q&1)&&a!==(a=B[1][0]+"")&&(r.innerHTML=a),(!H||q&1)&&_!==(_=B[1][1]+"")&&(f.innerHTML=_),(!H||q&1)&&P!==(P=B[1][2]+"")&&(O.innerHTML=P);const le={};q&1&&(le.name=Ie(B[1][0])),T.$set(le)},i(B){H||(v(T.$$.fragment,B),H=!0)},o(B){A(T.$$.fragment,B),H=!1},d(B){B&&b(e),W(T)}}}function pt(t){let e,n,r=t[0],a=[];for(let o=0;o<r.length;o+=1)a[o]=ye(_e(t,r,o));const i=o=>A(a[o],1,1,()=>{a[o]=null});return{c(){for(let o=0;o<a.length;o+=1)a[o].c();e=G()},m(o,l){for(let c=0;c<a.length;c+=1)a[c].m(o,l);g(o,e,l),n=!0},p(o,[l]){if(l&1){r=o[0];let c;for(c=0;c<r.length;c+=1){const s=_e(o,r,c);a[c]?(a[c].p(s,l),v(a[c],1)):(a[c]=ye(s),a[c].c(),v(a[c],1),a[c].m(e.parentNode,e))}for(Z(),c=r.length;c<a.length;c+=1)i(c);ee()}},i(o){if(!n){for(let l=0;l<r.length;l+=1)v(a[l]);n=!0}},o(o){a=a.filter(Boolean);for(let l=0;l<a.length;l+=1)A(a[l]);n=!1},d(o){ae(a,o),o&&b(e)}}}function Ie(t){return t=t.split("<")[0],t=t.split("(")[0],t=t.trim(),t}function ft(t,e,n){let{data:r}=e;return t.$$set=a=>{"data"in a&&n(0,r=a.data)},[r]}class bt extends V{constructor(e){super(),Q(this,e,ft,pt,R,{data:0})}}function gt(t){let e,n,r,a,i,o,l,c;return r=new bt({props:{data:pe.fieldsData}}),l=new Je({props:{data:pe.eventsData}}),{c(){e=p("h3"),e.textContent="Available fields for Web Apps",n=w(),x(r.$$.fragment),a=w(),i=p("h3"),i.textContent="Events Available for Web Apps",o=w(),x(l.$$.fragment),S(e,"class","svelte-1yquk9n"),S(i,"class","svelte-1yquk9n")},m(s,m){g(s,e,m),g(s,n,m),C(r,s,m),g(s,a,m),g(s,i,m),g(s,o,m),C(l,s,m),c=!0},p:k,i(s){c||(v(r.$$.fragment,s),v(l.$$.fragment,s),c=!0)},o(s){A(r.$$.fragment,s),A(l.$$.fragment,s),c=!1},d(s){s&&b(e),s&&b(n),W(r,s),s&&b(a),s&&b(i),s&&b(o),W(l,s)}}}class kt extends V{constructor(e){super(),Q(this,e,null,gt,R,{})}}new kt({target:document.getElementById("app")});
